import logging
import os
import shlex
import shutil
import subprocess
from os.path import join as pjoin
from typing import List, Tuple

import requests

from src.constants import ROOTED_BYPRODUCTS_DIR, BYPRODUCT_REPOSITORIES_DIR
from src.settings import GITLAB_TOKEN

HDH_GITLAB_URL = 'https://gitlab.com/healthdatahub'
GITLAB_COM_API_V4 = 'https://gitlab.com/api/v4'
LIST_TUPLE_STR_STR = List[Tuple[str, str]]


def update_all_byproducts(local) -> None:
    if not local and GITLAB_TOKEN is None:
        raise Exception("GITLAB TOKEN is not set. This is expected, if we are not executing on GitLab-CI runners, "
                        "for protected branches. Exiting, as we cannot automatically update byproducts.")

    last_commit_sha = exec_terminal("git rev-parse --verify HEAD").strip()
    logging.debug("Le hash SHA du dernier commit est '{}'".format(last_commit_sha))

    update_errors = 0
    update_errors += update_byproduct_repository(
        byproduct_repository='documentation-snds',
        local_to_byproduct_directories=[
            ('markdown', 'tables')],
        local_to_byproduct_files=[
            ('tables_sidebar.js',
             pjoin('.vuepress', 'tables_sidebar.js'))
        ],
        last_commit_sha=last_commit_sha,
        byproduct_project_id=11935953,
        automatic_merge=True,
        local=local)

    update_errors += update_byproduct_repository(
        byproduct_repository='dico-snds',
        local_to_byproduct_directories=[
            ('nomenclatures', pjoin('app', 'app_data', 'nomenclatures'))
        ],
        local_to_byproduct_files=[
            ('snds_links.csv', pjoin('app', 'app_data', 'snds_links.csv')),
            ('snds_nodes.csv', pjoin('app', 'app_data', 'snds_nodes.csv')),
            (
                'snds_tables.csv',
                pjoin('app', 'app_data', 'snds_tables.csv')),
            ('snds_vars.csv', pjoin('app', 'app_data', 'snds_vars.csv'))
        ],
        last_commit_sha=last_commit_sha,
        byproduct_project_id=11925754,
        automatic_merge=True,
        local=local)

    if update_errors:
        raise Exception("Their were {} errors in byproduct update. Look for ERROR logs.".format(update_errors))


def update_byproduct_repository(byproduct_repository: str,
                                local_to_byproduct_directories: LIST_TUPLE_STR_STR,
                                local_to_byproduct_files: LIST_TUPLE_STR_STR,
                                last_commit_sha: str,
                                byproduct_project_id: int,
                                automatic_merge: bool = False,
                                local: bool = False) -> int:
    """
    Update byproduct repository with byproducts generated with current schema

    :param last_commit_sha:
    :param byproduct_repository: Repository name
    :param byproduct_project_id: GitLab project id
    :param local_to_byproduct_directories: Directories to replace from locally generated byproduct to repository
    :param local_to_byproduct_files: Files to replace from locally generated byproduct to repository
    :param automatic_merge: Do we se tMerge Request to automatic merge when pipeline succeeds
    :param local: Do we update remote repository
    """
    logging.info("Mise à jour du dépôt '{}' avec la version courante du schéma".format(byproduct_repository))
    try:
        clone_byproduct_repository(byproduct_repository, local)
        update_local_byproduct_repository(byproduct_repository, local_to_byproduct_directories,
                                          local_to_byproduct_files)
        if not local:
            update_remote_byproduct_repository(last_commit_sha, byproduct_repository, byproduct_project_id,
                                               automatic_merge)
        return 0
    except Exception as e:
        logging.error(e)
        return 1


def clone_byproduct_repository(byproduct_repository, local):
    byproduct_repository_dir = get_byproduct_repository_dir(byproduct_repository)
    if local:
        gitlab_user_token = ''
    else:
        gitlab_user_token = 'oauth2:{}@'.format(GITLAB_TOKEN)

        logging.info("Suppression du dossier '{}'".format(byproduct_repository_dir))
        shutil.rmtree(byproduct_repository_dir, ignore_errors=True)

    if os.path.exists(byproduct_repository_dir):
        logging.info("Mise à jour du dépôt '{}' depuis le remote (git pull origin master)".format(byproduct_repository))
        current_dir = os.getcwd()
        os.chdir(byproduct_repository_dir)
        exec_terminal("git pull origin master")
        os.chdir(current_dir)
    else:
        logging.info("Clone du dépôt '{}' en local".format(byproduct_repository))
        exec_terminal("git clone https://{}gitlab.com/healthdatahub/{}.git {}".format(
            gitlab_user_token, byproduct_repository, byproduct_repository_dir.replace("\\", "/")))


def update_local_byproduct_repository(byproduct_repository: str,
                                      local_to_byproduct_directories: LIST_TUPLE_STR_STR,
                                      local_to_byproduct_files: LIST_TUPLE_STR_STR) -> None:
    logging.info("Copie des fichiers et dossiers générés vers la version locale du dépôt '{}'".format(
        get_byproduct_repository_dir(byproduct_repository)))
    for source_dir, target_dir in local_to_byproduct_directories:
        copy_directory_to_byproduct_repository(source_dir, byproduct_repository, target_dir)
    for source_file, target_file in local_to_byproduct_files:
        copy_file_to_byproduct_repository(source_file, byproduct_repository, target_file)


def update_remote_byproduct_repository(last_commit_sha: str,
                                       byproduct_repository: str,
                                       byproduct_project_id: int,
                                       automatic_merge: bool):
    current_dir = os.getcwd()
    os.chdir(get_byproduct_repository_dir(byproduct_repository))
    if not exec_terminal("git status --porcelain"):
        logging.info("Pas de différence entre le dépôt '{}' et le schéma courant.".format(byproduct_repository))
    else:
        logging.info("Il existe des différence entre le dépôt '{}' et le schéma courant. "
                     "Création d'un commit et d'une merge request pour le synchoniser.".format(byproduct_repository))

        exec_terminal("git config user.name 'schema-snds GitLab-CI robot'")
        exec_terminal('git config user.email "ld-lab-github@sante.gouv.fr"')
        branch_name = "update-from-schema-snds-{}".format(last_commit_sha)
        commit_and_push_modifications(branch_name, last_commit_sha)

        merge_request_iid = create_merge_request(byproduct_project_id, branch_name, byproduct_repository)
        if automatic_merge:
            merge_when_pipeline_succeeds(byproduct_project_id, merge_request_iid)
    os.chdir(current_dir)


def get_byproduct_repository_dir(byproduct_repository):
    return pjoin(BYPRODUCT_REPOSITORIES_DIR, byproduct_repository)


def copy_file_to_byproduct_repository(source_file: str, byproduct_repository: str, target_file: str) -> None:
    """
    Replace file in byproducts's repository local copy by source file.
    """
    source_file_path = pjoin(ROOTED_BYPRODUCTS_DIR, byproduct_repository, source_file)
    target_file_path = pjoin(BYPRODUCT_REPOSITORIES_DIR, byproduct_repository, target_file)
    shutil.copy(source_file_path, target_file_path)


def copy_directory_to_byproduct_repository(source_dir: str, byproduct_repository: str, target_dir: str) -> None:
    """
    Erase target directory in byproduct's repository local copy. Replace it with source directory.
    """
    source_dir_path = pjoin(ROOTED_BYPRODUCTS_DIR, byproduct_repository, source_dir)
    target_dir_path = pjoin(BYPRODUCT_REPOSITORIES_DIR, byproduct_repository, target_dir)
    shutil.rmtree(target_dir_path, ignore_errors=True)
    shutil.copytree(source_dir_path, target_dir_path)


def commit_and_push_modifications(branch_name: str, last_commit_sha: str):
    exec_terminal("git checkout -b {}".format(branch_name))
    exec_terminal("git add -A")

    commit_message = "MAJ automatique depuis 'schema-snds', commit {}\n\n" \
                     "Cf '{}/{}/commit/{}'".format(last_commit_sha, HDH_GITLAB_URL, 'schema-snds', last_commit_sha)

    exec_terminal("git commit -m '{}'".format(commit_message))
    exec_terminal("git push --set-upstream origin {}".format(branch_name))


def create_merge_request(project_id: int, source_branch: str, repository_name: str) -> int:
    logging.info("Create merge request for branch '{}".format(source_branch))
    r = requests.post(
        GITLAB_COM_API_V4 + "/projects/{}/merge_requests".format(project_id),
        params={
            'source_branch': source_branch,
            'target_branch': 'master',
            'title': "MAJ automatique depuis 'schema-snds'",
            'remove_source_branch': 'true',
            'private_token': GITLAB_TOKEN
        }
    )
    check_response_code(r)
    merge_request_iid = r.json()['iid']
    logging.info("Merge request '{}/{}/merge_requests/{}' was created.".format(
        HDH_GITLAB_URL, repository_name, merge_request_iid))
    return merge_request_iid


def merge_when_pipeline_succeeds(project_id: int, merge_request_iid: int) -> None:
    logging.info('Accept merge request with automatic merge when pipeline succeeds.')
    r = requests.post(
        GITLAB_COM_API_V4 + "/projects/{}/merge_requests/{}/approve".format(project_id, merge_request_iid),
        params={
            'private_token': GITLAB_TOKEN
        }
    )
    check_response_code(r)

    r = requests.put(
        GITLAB_COM_API_V4 + "/projects/{}/merge_requests/{}/merge".format(project_id, merge_request_iid),
        params={
            'merge_when_pipeline_succeeds': 'true',
            'private_token': GITLAB_TOKEN
        }
    )
    check_response_code(r)


def exec_terminal(command: str) -> str:
    logging.debug("Execute: {}".format(mask_gitlab_token(command)))
    bash_command_list = shlex.split(command)
    return subprocess.check_output(bash_command_list).decode()


def check_response_code(response: requests.Response) -> None:
    response_log_msg = '{} {}\n{}'.format(response.status_code, response.reason, response.text)
    response_log_msg = mask_gitlab_token(response_log_msg)
    if not str(response.status_code).startswith("20"):
        raise Exception("wrong status_code : {}".format(response.status_code))
    else:
        logging.debug(response_log_msg)


def mask_gitlab_token(text):
    if GITLAB_TOKEN is None:
        return text
    else:
        return text.replace(GITLAB_TOKEN, 'XXXXXXXX')
